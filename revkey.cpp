#include <cryptlib.h>
#include <aes.h>
#include <rsa.h>
#include <osrng.h>
#include <modes.h>
#include <filters.h>
#include <files.h>

#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <filesystem>
#include <algorithm>
#include <cctype>
#include <cstring>

using namespace CryptoPP;
namespace fs = std::filesystem;

const std::string PRIVATE_KEY_FILE = "rsa_private.der";
const std::string AES_KEY_ENC_FILE = "aes_key.enc";
const std::string ENCRYPTED_SUFFIX = ".revil";

// ====================== HELPER FUNCTIONS ======================

bool ends_with(const std::string& str, const std::string& suffix) {
    if (suffix.size() > str.size()) return false;
    return str.compare(str.size() - suffix.size(), suffix.size(), suffix) == 0;
}

std::string read_file_binary(const std::string& path) {
    std::ifstream f(path, std::ios::binary | std::ios::ate);
    if (!f) throw std::runtime_error("Cannot open: " + path);
    auto sz = f.tellg();
    std::string buf(sz, '\0');
    f.seekg(0);
    f.read(&buf[0], sz);
    return buf;
}

// ====================== LOAD & DECRYPT AES KEY ======================

SecByteBlock load_and_decrypt_aes_key() {
    std::cout << "[*] Loading private key: " << PRIVATE_KEY_FILE << "\n";
    if (!fs::exists(PRIVATE_KEY_FILE)) {
        throw std::runtime_error("rsa_private.der tidak ditemukan");
    }
    
    std::cout << "[*] Loading encrypted AES key: " << AES_KEY_ENC_FILE << "\n";
    if (!fs::exists(AES_KEY_ENC_FILE)) {
        throw std::runtime_error("aes_key.enc tidak ditemukan");
    }

    // Baca encrypted AES key
    std::string enc_aes = read_file_binary(AES_KEY_ENC_FILE);
    std::cout << "[*] Encrypted AES key size: " << enc_aes.size() << " bytes\n";

    // Load RSA private key
    RSA::PrivateKey privkey;
    FileSource fs(PRIVATE_KEY_FILE.c_str(), true);
    privkey.Load(fs);
    std::cout << "[âœ“] RSA private key loaded\n";

    // Decrypt AES key dengan RSA
    AutoSeededRandomPool rng;
    RSAES_OAEP_SHA_Decryptor decryptor(privkey);

    std::string aes_plain;
    StringSource ss(enc_aes, true,
        new PK_DecryptorFilter(rng, decryptor,
            new StringSink(aes_plain)
        )
    );

    if (aes_plain.size() != 32) {
        throw std::runtime_error("Panjang AES key harus 32 bytes (AES-256)");
    }

    std::cout << "[âœ“] AES-256 key berhasil didekripsi\n";
    return SecByteBlock(reinterpret_cast<const byte*>(aes_plain.data()), 32);
}

// ====================== DECRYPT SATU FILE ======================

bool decrypt_file(const std::string& lazy_path, const SecByteBlock& aes_key) {
    try {
        std::cout << "\nâ–¶ Memproses: " << lazy_path << "\n";
        
        // Validasi ekstensi
        if (!ends_with(lazy_path, ENCRYPTED_SUFFIX)) {
            std::cout << "  [!] Bukan file .revil, dilewati\n";
            return false;
        }
        
        // Baca file .lazy
        std::string content = read_file_binary(lazy_path);

        if (content.size() < AES::BLOCKSIZE) {
            std::cerr << "  [âœ—] File terlalu kecil (tidak ada IV)\n";
            return false;
        }

        // Ambil IV dari 16 byte pertama
        byte iv[AES::BLOCKSIZE];
        std::memcpy(iv, content.data(), AES::BLOCKSIZE);

        // Ciphertext setelah IV
        std::string ciphertext = content.substr(AES::BLOCKSIZE);
        std::cout << "  [*] IV size: 16 bytes, Ciphertext size: " << ciphertext.size() << " bytes\n";

        // Dekripsi dengan AES
        CBC_Mode<AES>::Decryption dec;
        dec.SetKeyWithIV(aes_key, aes_key.size(), iv);

        std::string plaintext;
        StringSource ss(ciphertext, true,
            new StreamTransformationFilter(dec,
                new StringSink(plaintext)
            )
        );

        // Tentukan nama file asli (tanpa .lazy)
        std::string original_path = lazy_path.substr(0, lazy_path.size() - ENCRYPTED_SUFFIX.size());
        std::cout << "  [*] Original filename: " << original_path << "\n";

        // Tulis file hasil dekripsi
        FileSink out(original_path.c_str());
        out.Put(reinterpret_cast<const byte*>(plaintext.data()), plaintext.size());
        std::cout << "  [âœ“] File berhasil didekripsi\n";

        // HAPUS FILE .LAZY SETELAH BERHASIL DEKRIPSI
        std::error_code ec;
        if (fs::remove(lazy_path, ec)) {
            std::cout << "  [âœ“] File .revil dihapus\n";
        } else {
            std::cout << "  [!] Gagal hapus .revil: " << ec.message() << "\n";
        }

        return true;

    } catch (const std::exception& e) {
        std::cerr << "  [âœ—] Error: " << e.what() << "\n";
        return false;
    }
}

// ====================== DECRYPT SEMUA FILE .LAZY ======================

void decrypt_all_files(const std::string& start_dir, const SecByteBlock& aes_key) {
    std::cout << "\n========================================\n";
    std::cout << "Mencari file .revil di: " << fs::absolute(start_dir) << "\n";
    std::cout << "========================================\n";
    
    std::vector<std::string> lazy_files;
    
    // Kumpulkan semua file .lazy
    for (const auto& entry : fs::recursive_directory_iterator(
            start_dir, fs::directory_options::skip_permission_denied)) {
        
        if (entry.is_regular_file()) {
            std::string path = entry.path().string();
            if (ends_with(path, ENCRYPTED_SUFFIX)) {
                lazy_files.push_back(path);
            }
        }
    }
    
    if (lazy_files.empty()) {
        std::cout << "\n[Tidak ada file .revil ditemukan]\n";
        return;
    }
    
    std::cout << "\nDitemukan " << lazy_files.size() << " file .revil\n";
    std::cout << "========================================\n";
    
    // Proses satu per satu
    int success = 0;
    int failed = 0;
    
    for (size_t i = 0; i < lazy_files.size(); i++) {
        std::cout << "\n[" << (i+1) << "/" << lazy_files.size() << "]";
        if (decrypt_file(lazy_files[i], aes_key)) {
            success++;
        } else {
            failed++;
        }
    }
    
    // Ringkasan
    std::cout << "\n========================================\n";
    std::cout << "RINGKASAN:\n";
    std::cout << "  âœ“ Berhasil: " << success << " file\n";
    if (failed > 0) {
        std::cout << "  âœ— Gagal: " << failed << " file\n";
    }
    std::cout << "  ðŸ“ File .revil otomatis dihapus setelah berhasil didekripsi\n";
    std::cout << "========================================\n";
}

// ====================== MAIN ======================

int main(int argc, char* argv[]) {
    std::cout << "\n";
    std::cout << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    std::cout << "â•‘      FILE DECRYPTOR v2.0           â•‘\n";
    std::cout << "â•‘   (Auto-delete .revil after decrypt)â•‘\n";
    std::cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";

    try {
        // Step 1: Load dan decrypt AES key
        std::cout << "[ FASE 1: MEMUAT KUNCI ]\n";
        SecByteBlock aes_key = load_and_decrypt_aes_key();
        
        // Step 2: Tentukan direktori
        std::string start_dir = ".";
        if (argc > 1) {
            start_dir = argv[1];
        }
        
        // Step 3: Decrypt semua file
        std::cout << "\n[ FASE 2: DEKRIPSI FILE ]\n";
        decrypt_all_files(start_dir, aes_key);
        
        // Step 4: Bersihkan memory
        memset(aes_key.data(), 0, aes_key.size());
        
        std::cout << "\nâœ“ PROSES SELESAI\n";
        std::cout << "  Semua file .revil telah didekripsi dan dihapus.\n";
        std::cout << "  File kembali ke ekstensi aslinya.\n\n";

    } catch (const std::exception& e) {
        std::cerr << "\n[ERROR FATAL] " << e.what() << "\n\n";
        std::cerr << "Pastikan file berikut ada:\n";
        std::cerr << "  1. " << PRIVATE_KEY_FILE << " (RSA private key)\n";
        std::cerr << "  2. " << AES_KEY_ENC_FILE << " (Encrypted AES key)\n\n";
        return 1;
    }

    return 0;
}
